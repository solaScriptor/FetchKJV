# -----------------------------
# SETTINGS MENU
# -----------------------------

def capture_hotkey(update_callback, display_label):
    popup = tk.Toplevel(hidden_root)
    popup.attributes("-topmost", True)
    popup.lift()
    popup.iconbitmap(resource_path("FetchKJV.ico"))
    popup.title("Set Hotkey")
    popup.geometry("300x90")
    popup.attributes("-topmost", True)

    tk.Label(popup, text="Press the desired hotkey...", font=("Segoe UI", 11)).pack(pady=20)

    pressed_mods = {"ctrl": False, "alt": False, "shift": False}

    def on_key(event):
        key = event.keysym

        # Track modifiers
        if key in ("Control_L", "Control_R", Key.ctrl_l, Key.ctrl_r, Key.ctrl):
            pressed_mods["ctrl"] = True
            return
        if key in ("Alt_L", "Alt_R", Key.alt_l, Key.alt_r, Key.alt_gr):
            pressed_mods["alt"] = True
            return
        if key in ("Shift_L", "Shift_R", Key.shift_l, Key.shift_r, Key.shift):
            pressed_mods["shift"] = True
            return
                
        # Build hotkey dict
        new_hotkey = {
            "key": key.lower(),
            "ctrl": pressed_mods["ctrl"],
            "alt": pressed_mods["alt"],
            "shift": pressed_mods["shift"]
        }

        update_callback(new_hotkey)

        # Update variable and label
        display_label.config(text=format_hotkey(new_hotkey))

        popup.destroy()

    popup.bind("<KeyPress>", on_key)
    popup.focus_force()

def open_settings_window():
    # Prevent multiple settings windows
    if any(isinstance(w, tk.Toplevel) and w.title() == "Settings" for w in hidden_root.winfo_children()):
        return

    win = tk.Toplevel(hidden_root)
    win.attributes("-topmost", True)
    win.lift()
    win.iconbitmap(resource_path("FetchKJV.ico"))
    win.configure(bg="#f7f5ea")
    win.title("FetchKJV Settings")
    win.geometry("270x270")
    win.resizable(False, False)

    # --- HOTKEY ---
    tk.Label(win, text="Select Desired Hotkey:", bg="#f7f5ea").pack(anchor="w", padx=10, pady=(10, 0))

    hotkey_frame = tk.Frame(win, bg="#f7f5ea")
    hotkey_frame.pack(fill="x", padx=10)

    # Store the dict directly
    hotkey_value = settings["hotkey"]  # a normal Python dict

    def update_hotkey(new_hotkey):
        nonlocal hotkey_value
        hotkey_value = new_hotkey

    # Display the hotkey in a readable format
    hotkey_display = tk.Label(hotkey_frame, text=format_hotkey(settings["hotkey"]), bg="#f7f5ea")
    hotkey_display.pack(side="left", fill="x", expand=True)

    # Button to capture a new hotkey
    tk.Button(
        hotkey_frame,
        text="Set Hotkey",
        command=lambda: capture_hotkey(lambda new: update_hotkey(new), hotkey_display),
        background="#beb09c"
    ).pack(side="right", padx=5)

   # --- AUTO CLOSE ---
    tk.Label(win, text="Pop ups close after x seconds:", bg="#f7f5ea").pack(anchor="w", padx=10, pady=(10, 0))

    auto_var = tk.IntVar(value=settings["auto_close_seconds"])

    # Display label above the spinner
    display_label = tk.Label(
        win,
        textvariable=auto_var,
        font=("Segoe UI", 10),
        bg="#f7f5ea",
        fg="#333333",
        anchor="center"
    )
    display_label.pack(padx=10, pady=(0, 5))

    # Then create the spinbox (with minimal width)
    spin = ttk.Spinbox(
        win,
        from_=1,
        to=60,
        textvariable=auto_var,
        width=1,
        font=("Segoe UI", 10),
        style="Custom.TSpinbox",
        justify="right",
        state="readonly"  # optional: prevents typing
    )
    spin.pack(padx=10)

    def on_mousewheel(event):
        if event.delta > 0:
            spin.event_generate("<Up>")
        else:
            spin.event_generate("<Down>")

    spin.bind("<Enter>", lambda e: spin.focus_set())
    spin.bind("<MouseWheel>", on_mousewheel)

    # --- COPY REFERENCES OPTION ---
    copy_ref_var = tk.BooleanVar(value=settings.get("copy_references", False))

    chk_copy_refs = tk.Checkbutton(
        win,
        text="Include verse references when copying",
        variable=copy_ref_var,
        font=("Segoe UI", 10),
        bg="#f7f5ea",
        activebackground="#f7f5ea"
    )
    chk_copy_refs.pack(anchor="w", padx=10, pady=(10, 0))

    # --- SAVE BUTTON ---
    def save_settings():
        new_settings = {
            "hotkey": hotkey_value,
            "auto_close_seconds": int(auto_var.get()),
            "copy_references": copy_ref_var.get(),
            "popup": {
                "bg_small": settings["popup"]["bg_small"],
                "bg_large": settings["popup"]["bg_large"],
                "text_color_small": settings["popup"]["text_color_small"],
                "font_large": settings["popup"]["font_large"],
                "font_small": settings["popup"]["font_small"],
                "width_large": settings["popup"]["width_large"],
                "height_large": settings["popup"]["height_large"]
            }
        }

        with open(SETTINGS_PATH, "w", encoding="utf-8") as f:
            json.dump(new_settings, f, indent=4)

        reload_settings()
        show_popup("Settings saved!", title="FetchKJV", small=True)
        win.destroy()


    # --- BUTTON ROW ---
    btn_frame = tk.Frame(win, bg="#f7f5ea")
    btn_frame.pack(pady=20)

    def cancel_settings():
        win.destroy()  # close without saving

    # Cancel button (left)
    tk.Button(
        btn_frame,
        text="Cancel",
        width=12,
        background="#beb09c",
        command=cancel_settings
    ).pack(side="left", padx=10)

    # Save button (right)
    tk.Button(
        btn_frame,
        text="Save",
        width=12,
        background="#beb09c",
        command=save_settings
    ).pack(side="left", padx=10)

    # Close behaviour
    win.protocol("WM_DELETE_WINDOW", win.destroy)

# Track modifier state
pressed_modifiers = {
    "ctrl": False,
    "alt": False,
    "shift": False
}
